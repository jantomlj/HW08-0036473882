package hr.fer.zemris.java.filechecking.syntax;

import java.util.ArrayList;
import java.util.List;

import hr.fer.zemris.java.filechecking.lexical.FileCheckingToken;
import hr.fer.zemris.java.filechecking.lexical.FileCheckingTokenType;
import hr.fer.zemris.java.filechecking.lexical.FileCheckingTokenizer;
import hr.fer.zemris.java.filechecking.syntax.nodes.*;

/**
 * Class that parses given file checking program in form of tokens and produces its program
 * node.
 * 
 * @author Jan TomljanoviÄ‡
 */
public class FileCheckingParser {

	private FileCheckingTokenizer tokenizer;
	private ProgramNode programNode;

	private int unclosedBrackets;


	/**
	 * Constructs the parser.
	 * 
	 * @param tokenizer
	 *            that contains information about the program that should be parsed
	 * @throws IllegalArgumentException
	 *             if tokenizer is null
	 */
	public FileCheckingParser(FileCheckingTokenizer tokenizer) {
		if (tokenizer == null) {
			throw new IllegalArgumentException("FileCheckingParses needs a tokenizer");
		}
		this.tokenizer = tokenizer;
		this.tokenizer.tokenize();  // tokenize once and work with a list of tokens
	}


	/**
	 * Method that starts parsing from some point in the program.
	 * 
	 * @param index
	 *            of the token where parsing will start
	 * @param inBrackets
	 *            should parsing end when brackets close (true), or when end of file is found
	 *            (false)
	 * @throws FileCheckingSyntaxException
	 *             if unable to parse
	 */
	protected void parseFrom(int index, boolean inBrackets) {
		unclosedBrackets = 0;
		tokenizer.startGettingTokensFrom(index);
		programNode = parse(inBrackets);
	}


	/**
	 * Method that parses the whole program
	 * 
	 * @throws FileCheckingSyntaxException
	 *             if unable to parse
	 */
	public void parse() {
		parseFrom(0, false);
	}


	/**
	 * Method that returns the program node generated by parsing the program. If parsing failed
	 * program node that is returned has undefined behaviour.
	 * 
	 * @return generated program node
	 */
	public ProgramNode getProgramNode() {
		return programNode;
	}


	/**
	 * Method that parses tokens into program node.
	 * 
	 * @param inBrackets
	 *            should parsing end when brackets close (true), or when end of file is found
	 *            (false)
	 * @return generated program node
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private ProgramNode parse(boolean inBrackets) {
		try {
			boolean not = false;
			List<FileCheckingNode> commands = new ArrayList<>();
			while (true) {
				FileCheckingToken token = tokenizer.nextToken();

				if (inBrackets && !not && token.getType() == FileCheckingTokenType.CLOSE_CURLY_BRACKETS) {
					if (unclosedBrackets > 0) {            // end of parsing because of closed bracket
						unclosedBrackets--;
					}
					break;
				}

				if (!inBrackets && !not && token.getType() == FileCheckingTokenType.EOF) {
					break;                 // end of parsing beacause of end of file
				}

				if (inBrackets && !not && token.getType() == FileCheckingTokenType.EOF) {
					throw new FileCheckingSyntaxException("Unclosed brackets", tokenizer.getPastListPos());
				}

				if (!not && token.getType() == FileCheckingTokenType.NOT) {
					not = true;
					continue;
				}

				if (!inBrackets && token.getType() == FileCheckingTokenType.CLOSE_CURLY_BRACKETS) {
					throw new FileCheckingSyntaxException("Closed bracket not expected", tokenizer.getPastListPos());
				}

				if (token.getType() != FileCheckingTokenType.KEYWORD) {
					throw new FileCheckingSyntaxException("Keyword expected. Maybe double '!'.",
							tokenizer.getPastListPos());
				}
				// keyword search
				if (token.getValue().equals("def") && !not) {
					commands.add(parseDef());
					continue;
				}
				if (token.getValue().equals("exists")) {
					commands.add(parseExists(not));
					not = false;
					continue;
				}
				if (token.getValue().equals("filename")) {
					commands.add(parseFilename(not));
					not = false;
					continue;
				}
				if (token.getValue().equals("format")) {
					commands.add(parseFormat(not));
					not = false;
					continue;
				}
				if (token.getValue().equals("terminate") && !not) {
					commands.add(parseTerminate());
					continue;
				}
				if (token.getValue().equals("fail")) {
					commands.add(parseFail(not));
					not = false;
					continue;
				}
				throw new FileCheckingSyntaxException(
						"Non-existant keyword found or '!' is in front of something not a test",
						tokenizer.getPastListPos());
			}
			return new ProgramNode(commands);
		} catch (FileCheckingSyntaxException e) {
			throw new FileCheckingSyntaxException(e.getMessage(), e.getListPosition());
		}
	}


	/**
	 * Method that parses command <code> def </code>
	 * 
	 * @return DefNode that represents def command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private DefNode parseDef() {
		FileCheckingToken token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.ARGUMENT) {
			throw new FileCheckingSyntaxException("Command def requires variable name", tokenizer.getPastListPos());
		}
		String name = getArgumentAsString(token);
		checkIfAllowed(name);

		token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.STRING) {
			throw new FileCheckingSyntaxException("Command def requires path", tokenizer.getPastListPos());
		}
		String path = (String) token.getValue();
		checkString(path);
		checkVariableInString(path);
		return new DefNode(name, path);
	}


	/**
	 * Method that parses command <code> exists </code>
	 * 
	 * @param reverse
	 *            Is meaning of the command reversed (was there <code>!</code> before the
	 *            command)
	 * @return ExistsNode that represents exists command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private ExistsNode parseExists(boolean reverse) {
		FileCheckingToken token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.ARGUMENT) {
			throw new FileCheckingSyntaxException("File or directory specification expected",
					tokenizer.getPastListPos());
		}
		String spec = getArgumentAsString(token);
		checkIfAllowed(spec);

		boolean directory;
		if (spec.matches("f|fi|fil|file")) {
			directory = false;
		} else if (spec.matches("d|di|dir")) {
			directory = true;
		} else {
			throw new FileCheckingSyntaxException("File or directory specification expected",
					tokenizer.getPastListPos());
		}

		token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.STRING) {
			throw new FileCheckingSyntaxException("Path expected", tokenizer.getPastListPos());
		}
		String path = (String) token.getValue();
		checkString(path);
		checkVariableInString(path);

		List<FileCheckingNode> commands = new ArrayList<>();
		String message = getLastTwoArgs(commands);
		if (commands.size() == 0) {
			commands = null;
		}
		return new ExistsNode(directory, path, message, commands, reverse);
	}


	/**
	 * Method that parses command <code> filename </code>
	 * 
	 * @param reverse
	 *            Is meaning of the command reversed (was there <code>!</code> before the
	 *            command)
	 * @return FilenameNode that represents filename command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private FilenameNode parseFilename(boolean reverse) {
		FileCheckingToken token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.STRING) {
			throw new FileCheckingSyntaxException("Filename argument must be string", tokenizer.getPastListPos());
		}
		String path = (String) token.getValue();
		checkString(path);
		checkVariableInString(path);

		List<FileCheckingNode> commands = new ArrayList<>();
		String message = getLastTwoArgs(commands);
		if (commands.size() == 0) {
			commands = null;
		}
		return new FilenameNode(path, message, commands, reverse);
	}


	/**
	 * Method that parses command <code> format </code>
	 * 
	 * @param reverse
	 *            Is meaning of the command reversed (was there <code>!</code> before the
	 *            command)
	 * @return FormatNode that represents format command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private FormatNode parseFormat(boolean reverse) {
		FileCheckingToken token = tokenizer.nextToken();
		if (token.getType() != FileCheckingTokenType.ARGUMENT) {
			throw new FileCheckingSyntaxException("Format needs a format as an argument", tokenizer.getPastListPos());
		}
		String format = getArgumentAsString(token);
		checkIfAllowed(format);

		List<FileCheckingNode> commands = new ArrayList<>();
		String message = getLastTwoArgs(commands);
		if (commands.size() == 0) {
			commands = null;
		}
		return new FormatNode(format, message, commands, reverse);
	}


	/**
	 * Method that parses command <code> fail </code>
	 * 
	 * @param reverse
	 *            Is meaning of the command reversed (was there <code>!</code> before the
	 *            command)
	 * @return FailNode that represents fail command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private FailNode parseFail(boolean reverse) {
		List<FileCheckingNode> commands = new ArrayList<>();
		String message = getLastTwoArgs(commands);
		if (commands.size() == 0) {
			commands = null;
		}
		return new FailNode(message, commands, reverse);
	}


	/**
	 * Method that parses command <code> terminate </code>
	 * 
	 * @return TerminateNode that represents terminate command
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private TerminateNode parseTerminate() {
		return new TerminateNode();
	}


	/**
	 * Method that handles last two arguments of a {@link TestNode}. It returns the message if
	 * messege is provided, and it fills argument commands if commands are provided
	 * 
	 * @param commands
	 *            empty list should be provided so that it can be filled with possible commands
	 *            found while parsing
	 * @return Messege that is found. Null if there is no message.
	 * @throws FileCheckingSyntaxException
	 *             if parsing fails
	 */
	private String getLastTwoArgs(List<FileCheckingNode> commands) {
		FileCheckingToken token = tokenizer.nextToken();
		String message = null;
		if (token.getType() == FileCheckingTokenType.STRING) {
			if (((String) token.getValue()).charAt(0) != '@') {
				throw new FileCheckingSyntaxException("Message or commands expected", tokenizer.getPastListPos());
			}
			message = (String) token.getValue();
			checkString(message);
			token = tokenizer.nextToken();
		}

		if (token.getType() == FileCheckingTokenType.OPEN_CURLY_BRACKETS) {
			unclosedBrackets++;
			commands.addAll(parse(true).getCommands());
		} else {
			tokenizer.oneTokenBack();
		}
		return message;
	}


	/**
	 * Method that returns found argument as string.
	 * 
	 * @param token
	 *            Token of type argument
	 * @return string that represents the given token
	 * @throws FileCheckingSyntaxException
	 *             if given tokens value is not a string
	 */
	private String getArgumentAsString(FileCheckingToken token) throws FileCheckingSyntaxException {
		String name;
		if (token.getValue() instanceof String) {
			name = (String) token.getValue();
		} else {
			throw new FileCheckingSyntaxException("Argument name must be string", tokenizer.getPastListPos());
		}
		return name;
	}


	/**
	 * Method that asserts that given string is valid.
	 * 
	 * @param string
	 *            to be checked
	 * @throws FileCheckingSyntaxException
	 *             if string is not vaild
	 */
	private void checkString(String string) {
		if (string.contains("\\")) {
			throw new FileCheckingSyntaxException("Invalid string", tokenizer.getPastListPos());
		}
		boolean opened = false;
		for (int i = 0; i < string.length(); i++) {
			if (string.charAt(i) == '$' && string.charAt(i + 1) != '{') {
				throw new FileCheckingSyntaxException("Invalid string", tokenizer.getPastListPos());
			}
			if (string.charAt(i) == '{' && string.charAt(i - 1) != '$') {
				throw new FileCheckingSyntaxException("Invalid string", tokenizer.getPastListPos());
			}
			if (string.charAt(i) == '{' && string.charAt(i - 1) == '$') {
				opened = true;
			}
			if (string.charAt(i) == '}') {
				if (opened) {
					opened = false;
				} else {
					throw new FileCheckingSyntaxException("Invalid string", tokenizer.getPastListPos());
				}
			}
		}
	}


	/**
	 * Method that asserts that given string is a valid argument
	 * 
	 * @param s
	 *            string to be checked
	 * @throws FileCheckingSyntaxException
	 *             if string is not a valid argument
	 */
	private void checkIfAllowed(String s) {
		for (int i = 0; i < s.length(); i++) {
			if (i == 0 && Character.isDigit(s.charAt(i))) {
				throw new FileCheckingSyntaxException("Invalid argument name", tokenizer.getPastListPos());
			}
			if (!Character.isAlphabetic(s.charAt(i)) && !Character.isDigit(s.charAt(i)) && s.charAt(i) != '.'
					&& s.charAt(i) != '_') {
				throw new FileCheckingSyntaxException("Invalid argument name", tokenizer.getPastListPos());
			}
		}
	}


	/**
	 * Method that asserts that variables specified in the string (if exist) are valid.
	 * 
	 * @param s
	 *            string in which variables are checked
	 * @throws FileCheckingSyntaxException
	 *             if variable is found ant isn't valid
	 */
	private void checkVariableInString(String s) {
		int start;
		int end = 0;
		while (true) {
			start = s.indexOf("${", end + 1);
			end = s.indexOf("}", end + 1);
			if (start != -1 && end != -1) {
				String sub = s.substring(start + 2, end).trim();
				try {
					checkIfAllowed(sub);
				} catch (FileCheckingSyntaxException e) {
					throw new FileCheckingSyntaxException("Illegal variable name in string", e.getListPosition());
				}
				continue;
			}
			break;
		}
	}


	/**
	 * Method that finds the first next keyword token starting from the given position in the
	 * list of tokens.
	 * 
	 * @param index
	 *            position in the list of tokens
	 * @return position of the first next keyword in the list of tokens
	 */
	protected int findNextKeywordFrom(int index) {
		tokenizer.startGettingTokensFrom(index);
		FileCheckingToken token;
		while (true) {
			token = tokenizer.nextToken();
			if (token.getType() == FileCheckingTokenType.EOF) {
				return -1;
			}
			if (token.getType() == FileCheckingTokenType.KEYWORD) {
				return tokenizer.getPastListPos();
			}
		}
	}


	/**
	 * Method checks whether there is a bracket (one bracket) present between start (inclusive)
	 * and end (exclusive) index in the token list.
	 * 
	 * @param start
	 *            position in the list
	 * @param end
	 *            position in the list
	 * @return if there is no brackets: 0 <br>
	 *         if there is an open bracket: 1 <br>
	 *         if there is a closed bracket: -1
	 */
	protected int bracketsAppearBetween(int start, int end) {
		tokenizer.startGettingTokensFrom(start);
		FileCheckingToken token;
		for (int i = start; i < end; i++) {
			token = tokenizer.nextToken();
			if (token.getType() == FileCheckingTokenType.EOF) {
				throw new IllegalArgumentException("Bad bound given");
			}
			if (token.getType() == FileCheckingTokenType.CLOSE_CURLY_BRACKETS) {
				return -1;
			}
			if (token.getType() == FileCheckingTokenType.OPEN_CURLY_BRACKETS) {
				return 1;
			}
		}
		return 0;
	}


	/**
	 * Method that returns the current number of unclosed brackets.
	 * 
	 * @return number of unclosed brackets
	 */
	protected int numOfUnclosedBrackets() {
		return unclosedBrackets;
	}

}